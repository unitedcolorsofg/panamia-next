#!/usr/bin/env npx tsx
/**
 * Update MongoDB Document References Script
 *
 * This script updates MongoDB documents to use the new PostgreSQL user IDs
 * after auth migration. It reads the ID mapping file generated by
 * import-auth-data.ts and updates all user references across collections.
 *
 * Usage: npx tsx scripts/update-mongo-references.ts <id-mapping-file.json>
 *
 * Example: npx tsx scripts/update-mongo-references.ts scripts/id-mapping-2024-01-15.json
 *
 * Collections updated:
 *   - profiles (userId)
 *   - images (userId)
 *   - followers (userId)
 *   - emailMigrations (userId)
 *   - articles (authorId, coAuthors.userId, reviews.userId)
 *   - notifications (actor, target)
 *
 * The script runs in DRY_RUN mode by default. Set DRY_RUN=false to apply changes.
 */

import { MongoClient, ObjectId } from 'mongodb';
import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';
import { config } from 'dotenv';

// Load environment variables from .env.local (Next.js convention)
config({ path: '.env.local' });

interface IdMapping {
  createdAt: string;
  exportFile: string;
  users: Record<string, string>; // MongoDB ObjectId string -> PostgreSQL cuid
  accounts: Record<string, string>;
  sessions: Record<string, string>;
}

interface UpdateResult {
  collection: string;
  field: string;
  matched: number;
  modified: number;
  notMapped: string[];
}

async function main() {
  const args = process.argv.slice(2);
  if (args.length === 0) {
    console.error(
      'Usage: npx tsx scripts/update-mongo-references.ts <id-mapping-file.json>'
    );
    console.error(
      '\nExample: npx tsx scripts/update-mongo-references.ts scripts/id-mapping-2024-01-15.json'
    );
    process.exit(1);
  }

  const mappingFilePath = args[0];
  if (!existsSync(mappingFilePath)) {
    console.error(`Error: ID mapping file not found: ${mappingFilePath}`);
    process.exit(1);
  }

  // Check for DRY_RUN mode
  const isDryRun = process.env.DRY_RUN !== 'false';
  if (isDryRun) {
    console.log('üîç DRY RUN MODE - No changes will be written to MongoDB');
    console.log('   Set DRY_RUN=false to apply changes\n');
  } else {
    console.log('‚ö†Ô∏è  LIVE MODE - Changes WILL be written to MongoDB\n');
  }

  // Read ID mapping file
  console.log(`üìñ Reading ID mapping file: ${mappingFilePath}`);
  const idMapping: IdMapping = JSON.parse(
    readFileSync(mappingFilePath, 'utf-8')
  );

  const userIdMap = idMapping.users;
  const mappingCount = Object.keys(userIdMap).length;
  console.log(`   Found ${mappingCount} user ID mappings`);

  if (mappingCount === 0) {
    console.error('Error: No user ID mappings found in file');
    process.exit(1);
  }

  // Connect to MongoDB
  const mongoUri = process.env.MONGODB_URI;
  if (!mongoUri) {
    console.error('Error: MONGODB_URI environment variable is not set');
    process.exit(1);
  }

  console.log('\nüîå Connecting to MongoDB...');
  const client = new MongoClient(mongoUri);

  const results: UpdateResult[] = [];

  try {
    await client.connect();
    const db = client.db();

    // Helper function to update a collection
    async function updateCollection(
      collectionName: string,
      fieldPath: string,
      isObjectId: boolean = false
    ): Promise<UpdateResult> {
      const collection = db.collection(collectionName);
      const result: UpdateResult = {
        collection: collectionName,
        field: fieldPath,
        matched: 0,
        modified: 0,
        notMapped: [],
      };

      // Find all documents with the field set
      const query: Record<string, unknown> = {};
      query[fieldPath] = { $exists: true, $ne: null };

      const documents = await collection.find(query).toArray();
      result.matched = documents.length;

      console.log(
        `\nüì¶ ${collectionName}.${fieldPath}: Found ${documents.length} documents`
      );

      for (const doc of documents) {
        // Get the current value (handle nested paths)
        const pathParts = fieldPath.split('.');
        let currentValue: unknown = doc;
        for (const part of pathParts) {
          if (currentValue && typeof currentValue === 'object') {
            currentValue = (currentValue as Record<string, unknown>)[part];
          } else {
            currentValue = undefined;
            break;
          }
        }

        if (!currentValue) continue;

        // Convert ObjectId to string if needed
        const oldId = isObjectId
          ? (currentValue as ObjectId).toString()
          : String(currentValue);

        // Look up the new ID
        const newId = userIdMap[oldId];

        if (!newId) {
          // Check if it's already a cuid (already migrated or new user)
          if (oldId.startsWith('c') && oldId.length >= 20) {
            // Likely already a cuid, skip
            continue;
          }
          result.notMapped.push(oldId);
          continue;
        }

        if (oldId === newId) {
          // Already updated
          continue;
        }

        if (!isDryRun) {
          const updateQuery: Record<string, unknown> = {};
          updateQuery[fieldPath] = newId;

          await collection.updateOne({ _id: doc._id }, { $set: updateQuery });
        }
        result.modified++;
      }

      if (result.notMapped.length > 0) {
        console.log(
          `   ‚ö†Ô∏è  ${result.notMapped.length} documents have unmapped user IDs`
        );
      }
      console.log(
        `   ${isDryRun ? 'Would update' : 'Updated'}: ${result.modified} documents`
      );

      return result;
    }

    // Helper for array fields (like coAuthors)
    async function updateArrayField(
      collectionName: string,
      arrayField: string,
      userIdField: string,
      isObjectId: boolean = false
    ): Promise<UpdateResult> {
      const collection = db.collection(collectionName);
      const result: UpdateResult = {
        collection: collectionName,
        field: `${arrayField}.${userIdField}`,
        matched: 0,
        modified: 0,
        notMapped: [],
      };

      // Find all documents with the array field
      const query: Record<string, unknown> = {};
      query[arrayField] = { $exists: true, $not: { $size: 0 } };

      const documents = await collection.find(query).toArray();
      result.matched = documents.length;

      console.log(
        `\nüì¶ ${collectionName}.${arrayField}[].${userIdField}: Found ${documents.length} documents`
      );

      for (const doc of documents) {
        const arrayValue = doc[arrayField] as Array<Record<string, unknown>>;
        if (!Array.isArray(arrayValue)) continue;

        let docModified = false;
        const updatedArray = arrayValue.map((item) => {
          const currentValue = item[userIdField];
          if (!currentValue) return item;

          const oldId = isObjectId
            ? (currentValue as ObjectId).toString()
            : String(currentValue);

          const newId = userIdMap[oldId];

          if (!newId) {
            if (!(oldId.startsWith('c') && oldId.length >= 20)) {
              if (!result.notMapped.includes(oldId)) {
                result.notMapped.push(oldId);
              }
            }
            return item;
          }

          if (oldId !== newId) {
            docModified = true;
            return { ...item, [userIdField]: newId };
          }

          return item;
        });

        if (docModified) {
          if (!isDryRun) {
            const updateQuery: Record<string, unknown> = {};
            updateQuery[arrayField] = updatedArray;
            await collection.updateOne({ _id: doc._id }, { $set: updateQuery });
          }
          result.modified++;
        }
      }

      if (result.notMapped.length > 0) {
        console.log(
          `   ‚ö†Ô∏è  ${result.notMapped.length} unique unmapped user IDs in array`
        );
      }
      console.log(
        `   ${isDryRun ? 'Would update' : 'Updated'}: ${result.modified} documents`
      );

      return result;
    }

    // Update each collection
    console.log('\nüìù Updating MongoDB collections...');

    // profiles.userId (String)
    results.push(await updateCollection('profiles', 'userId', false));

    // images.userId (String)
    results.push(await updateCollection('images', 'userId', false));

    // followers.userId (String)
    results.push(await updateCollection('followers', 'userId', false));

    // emailmigrations.userId (String)
    results.push(await updateCollection('emailmigrations', 'userId', false));

    // articles.authorId (String - despite schema showing ObjectId ref)
    results.push(await updateCollection('articles', 'authorId', false));

    // articles.coAuthors[].userId (ObjectId)
    results.push(
      await updateArrayField('articles', 'coAuthors', 'userId', true)
    );

    // articles.reviews[].userId (ObjectId)
    results.push(await updateArrayField('articles', 'reviews', 'userId', true));

    // notifications.actor (ObjectId ref to user)
    results.push(await updateCollection('notifications', 'actor', true));

    // notifications.target (ObjectId ref to user)
    results.push(await updateCollection('notifications', 'target', true));

    // Generate summary report
    console.log('\n' + '='.repeat(60));
    console.log('üìä SUMMARY REPORT');
    console.log('='.repeat(60));

    let totalMatched = 0;
    let totalModified = 0;
    const allNotMapped: string[] = [];

    for (const r of results) {
      totalMatched += r.matched;
      totalModified += r.modified;
      for (const id of r.notMapped) {
        if (!allNotMapped.includes(id)) {
          allNotMapped.push(id);
        }
      }
      console.log(`\n${r.collection}.${r.field}:`);
      console.log(`   Matched: ${r.matched}`);
      console.log(
        `   ${isDryRun ? 'Would modify' : 'Modified'}: ${r.modified}`
      );
      if (r.notMapped.length > 0) {
        console.log(`   Unmapped IDs: ${r.notMapped.length}`);
      }
    }

    console.log('\n' + '-'.repeat(60));
    console.log(`TOTAL: ${totalMatched} documents matched`);
    console.log(
      `TOTAL: ${totalModified} documents ${isDryRun ? 'would be modified' : 'modified'}`
    );

    if (allNotMapped.length > 0) {
      console.log(
        `\n‚ö†Ô∏è  ${allNotMapped.length} unique user IDs not in mapping:`
      );
      console.log(
        '   These may be unclaimed profiles or users created after export'
      );

      // Write unmapped IDs to a file for review
      const unmappedFilePath = join(
        process.cwd(),
        'scripts',
        `unmapped-user-ids-${new Date().toISOString().replace(/[:.]/g, '-')}.json`
      );
      writeFileSync(
        unmappedFilePath,
        JSON.stringify(
          {
            createdAt: new Date().toISOString(),
            count: allNotMapped.length,
            ids: allNotMapped,
          },
          null,
          2
        )
      );
      console.log(`   Written to: ${unmappedFilePath}`);
    }

    if (isDryRun) {
      console.log(
        '\n‚úÖ Dry run complete. Run with DRY_RUN=false to apply changes.'
      );
    } else {
      console.log('\n‚úÖ Update complete!');
    }
  } catch (error) {
    console.error('\n‚ùå Error updating MongoDB references:', error);
    process.exit(1);
  } finally {
    await client.close();
  }
}

main();
