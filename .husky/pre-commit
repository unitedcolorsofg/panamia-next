#!/bin/sh

# =============================================================================
# External Code Protection (activities.next subtree)
# =============================================================================

echo ""
echo "üîí Checking for modifications to external code..."

# Check for modifications to external/activities.next
EXTERNAL_CHANGES=$(git diff --cached --name-only | grep "^external/activities.next/" || true)

if [ -n "$EXTERNAL_CHANGES" ]; then
  echo ""
  echo "‚ùå ERROR: Modifications to external/activities.next/ are not allowed!"
  echo ""
  echo "The following files were modified:"
  echo "$EXTERNAL_CHANGES" | sed 's/^/  /'
  echo ""
  echo "This directory contains read-only upstream code from activities.next."
  echo "To update upstream code, use:"
  echo "  git subtree pull --prefix=external/activities.next activities-upstream main --squash"
  echo ""
  echo "If you need to extend functionality, create wrappers in lib/federation/"
  exit 1
fi

echo "‚ÑπÔ∏è  No modifications to external code"

# =============================================================================
# Prisma Migration Validation
# =============================================================================

echo ""
echo "üóÑÔ∏è  Checking Prisma migration standards..."

# Check for NEW migrations (additions only)
STAGED_MIGRATIONS=$(git diff --cached --name-only --diff-filter=A | grep -E '^prisma/migrations/[^/]+/migration\.sql$' || true)
STAGED_MIGRATION_DIRS=$(git diff --cached --name-only --diff-filter=A | grep -E '^prisma/migrations/' | grep -v 'migration_lock.toml' | grep -v 'TEMPLATE.sql' || true)

# Check for MODIFIED existing migrations (not allowed)
MODIFIED_MIGRATIONS=$(git diff --cached --name-only --diff-filter=M | grep -E '^prisma/migrations/[^/]+/migration\.sql$' || true)

if [ -n "$MODIFIED_MIGRATIONS" ]; then
  echo ""
  echo "‚ùå ERROR: Cannot modify existing migrations!"
  echo "   Migrations are immutable once committed."
  echo "   Create a new migration instead."
  echo ""
  echo "Modified files:"
  echo "$MODIFIED_MIGRATIONS" | sed 's/^/  /'
  echo ""
  echo "üí° Use 'npx prisma migrate dev --name fix_description' to create a new migration"
  exit 1
fi

# Validate new migrations with the validation script
if [ -n "$STAGED_MIGRATION_DIRS" ]; then
  if [ -x "scripts/validate-migrations.sh" ]; then
    ./scripts/validate-migrations.sh --staged || exit 1
  else
    echo "‚ö†Ô∏è  Warning: scripts/validate-migrations.sh not found or not executable"
  fi
else
  echo "‚ÑπÔ∏è  No new migrations to validate"
fi

# =============================================================================
# Playwright Test Coverage Check
# =============================================================================

echo ""
echo "üîç Checking Playwright test coverage for modified pages..."

# Get staged app pages (|| true prevents exit on no matches with set -e)
STAGED_PAGES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '^app/.*page\.tsx$' || true)

if [ -n "$STAGED_PAGES" ]; then
  # Collect uncovered pages first (avoids subshell variable issue)
  UNCOVERED_PAGES=""

  for page in $STAGED_PAGES; do
    # Extract route
    ROUTE=$(echo "$page" | sed 's|^app||' | sed 's|/page\.tsx$||')
    [ -z "$ROUTE" ] && ROUTE="/"

    # Check for test coverage (use || true to handle set -e)
    FOUND_EXACT=$(grep -rq "goto(['\"\`]$ROUTE['\"\`])" tests/ 2>/dev/null && echo "1" || true)
    FOUND_PARTIAL=$(grep -rq "goto(['\"\`].*$ROUTE" tests/ 2>/dev/null && echo "1" || true)
    if [ -z "$FOUND_EXACT" ] && [ -z "$FOUND_PARTIAL" ]; then
      UNCOVERED_PAGES="$UNCOVERED_PAGES
  üìÑ $page ‚Üí $ROUTE"
    fi
  done

  if [ -n "$UNCOVERED_PAGES" ]; then
    echo ""
    echo "‚ö†Ô∏è  WARNING: Modified pages may not have Playwright test coverage:"
    echo "$UNCOVERED_PAGES"
    echo ""
    echo "üí° Consider adding test cases to tests/e2e/"
    echo "   Run 'npm run test:ui' to create tests interactively"
    echo ""
  fi
fi

# Check for new folders without README.md
echo ""
echo "üìÅ Checking for new folders without README.md..."

# Get all staged files and extract unique directories
STAGED_DIRS=$(git diff --cached --name-only --diff-filter=A | xargs -I{} dirname {} 2>/dev/null | sort -u || true)

if [ -n "$STAGED_DIRS" ]; then
  MISSING_READMES=""

  for dir in $STAGED_DIRS; do
    # Skip root, node_modules, .git, etc.
    case "$dir" in
      .|node_modules*|.git*|.next*|.vercel*|public/*)
        continue
        ;;
    esac

    # Check if this is a new directory (all files in it are being added)
    # and if it's missing a README.md
    if [ -d "$dir" ] && [ ! -f "$dir/README.md" ]; then
      # Check if README.md is being added in this commit
      ADDING_README=$(git diff --cached --name-only | grep -q "^$dir/README.md$" && echo "1" || true)
      if [ -z "$ADDING_README" ]; then
        MISSING_READMES="$MISSING_READMES
  üìÇ $dir"
      fi
    fi
  done

  if [ -n "$MISSING_READMES" ]; then
    echo ""
    echo "‚ö†Ô∏è  WARNING: New folders may be missing README.md:"
    echo "$MISSING_READMES"
    echo ""
    echo "üí° Consider adding a README.md to explain the folder's purpose"
    echo ""
  fi
fi

# =============================================================================
# README Staleness Check (all directories with README.md)
# =============================================================================

echo ""
echo "üìú Checking for stale README.md files..."

# Find all directories with README.md (exclude external/, node_modules/, .git/, .next/)
README_DIRS=$(find . -name "README.md" -type f \
  -not -path "./external/*" \
  -not -path "./node_modules/*" \
  -not -path "./.git/*" \
  -not -path "./.next/*" \
  -exec dirname {} \; 2>/dev/null | sort -u || true)

STALE_READMES=""

for dir in $README_DIRS; do
  # Remove leading ./ for cleaner paths
  clean_dir="${dir#./}"
  [ "$clean_dir" = "." ] && clean_dir=""

  # Build pattern for files in this directory (excluding the README itself)
  if [ -z "$clean_dir" ]; then
    # Root directory - check for root-level file changes
    pattern="^[^/]+$"
  else
    pattern="^${clean_dir}/[^/]+"
  fi

  # Check if any files in this directory are staged (excluding README.md)
  STAGED_IN_DIR=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null | grep -E "$pattern" | grep -v "README.md$" || true)

  if [ -n "$STAGED_IN_DIR" ]; then
    # Check if README.md in this directory is also being updated
    if [ -z "$clean_dir" ]; then
      readme_path="README.md"
    else
      readme_path="${clean_dir}/README.md"
    fi

    README_UPDATED=$(git diff --cached --name-only | grep -q "^${readme_path}$" && echo "1" || true)

    if [ -z "$README_UPDATED" ]; then
      STALE_READMES="$STALE_READMES
  üìÇ ${readme_path}"
    fi
  fi
done

if [ -n "$STALE_READMES" ]; then
  echo ""
  echo "‚ö†Ô∏è  WARNING: Files changed in directories without updating README.md:"
  echo "$STALE_READMES"
  echo ""
  echo "üí° Consider updating the README.md files if the changes affect documentation"
  echo ""
fi

# Run linting
npx lint-staged
